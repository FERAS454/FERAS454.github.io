[{"content":"This post explores some of PowerShell commands that I\u0026rsquo;ve found invaluable for rapid triage during investigations.\nSystem Information System Info: 1 Get-ComputerInfo Process Management Running Processes: 1 Get-Process Kill Process by Name: 1 Stop-Process -Name \u0026#34;NameOfProcess\u0026#34; -Force List Running Processes, Parent Process, and Path: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Get-WmiObject -Class Win32_Process | ForEach-Object { $processID = $_.ProcessID $parentProcessID = $_.ParentProcessID $parentProcess = Get-WmiObject -Class Win32_Process -Filter \u0026#34;ProcessID=\u0026#39;$parentProcessID\u0026#39;\u0026#34; [PSCustomObject]@{ ProcessName = $_.Name ProcessID = $processID ParentProcessName = $parentProcess.Name ExecutablePath = $_.ExecutablePath CommandLine = $_.CommandLine } } Generate Hashes of All Running Processes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Get-Process | ForEach-Object { try { $hash = Get-FileHash $_.Path -Algorithm SHA256 Write-Output \u0026#34;$($_.ProcessName), $hash\u0026#34; } catch { Write-Output \u0026#34;$($_.ProcessName), $_.Exception.Message\u0026#34; } } Network Information Network Connections: 1 Get-NetTCPConnection Get Listening Ports: 1 Get-NetTCPConnection -State Listen | Select-Object LocalAddress, LocalPort, OwningProcess, OwningProcessName ARP Table: 1 Get-NetNeighbor 1 Get-NetNeighbor | Where-Object {$_.State -eq \u0026#39;Reachable\u0026#39;} | Format-Table IPAddress, LinkLayerAddress, State Check for Open RDP Sessions 1 Get-WmiObject -Class Win32_Session | Where-Object {$_.SessionType -eq \u0026#34;RDP\u0026#34;} Check DNS Cache for Signs of DNS Hijacking 1 Get-DnsClientCache Get Active Network Shares 1 Get-SmbShare File System and Registry Traverse Filesystem: 1 2 Get-ChildItem [file] | Format-List * Get File Metadata: 1 2 Get-ItemProperty C:\\Test\\Weather.xls | Format-List File Hash Calculation: 1 2 Get-FileHash -Algorithm MD5 C:\\path\\to\\file Find Large Files: 1 2 gci -r | sort -descending -property length | select -first 10 name, length, directory Files Created or Modified Between Two Dates: 1 2 Get-ChildItem -Path \u0026#34;C:\\Path\\to\\folder\u0026#34; -Recurse | Where-Object {($_.CreationTime -ge (Get-Date \u0026#34;2023-06-11\u0026#34;)) -and ($_.CreationTime -le (Get-Date \u0026#34;2023-06-22\u0026#34;)) -or ($_.LastWriteTime -ge (Get-Date \u0026#34;2023-06-11\u0026#34;)) -and ($_.LastWriteTime -le (Get-Date \u0026#34;2023-06-22\u0026#34;))} | Select-Object FullName, CreationTime, LastWriteTime Search for File by Hash: 1 2 Get-ChildItem -Path C:\\ -Recurse -File | Get-FileHash | Where-Object Hash -eq \u0026#39;HASH_VALUE\u0026#39; | Select-Object Path Search for File by Name: 1 2 Get-ChildItem -Path \u0026#34;C:\\Path\\To\\Search\u0026#34; -Filter \u0026#34;FileName\u0026#34; File Changed in Last 24 Hours: 1 2 Get-ChildItem -Path C:\\ -Recurse -File -Force | Where-Object { $_.LastWriteTime -ge (Get-Date).AddHours(-6) } Files Created in Last 24 Hours: 1 2 Get-ChildItem -Path C:\\ -Recurse -File -Force | Where-Object { $_.CreationTime -ge (Get-Date).AddHours(-6) } Obtain List of All Files: 1 2 3 4 tree C:\\ /F \u0026gt; output.txt dir C:\\ /A:H /-C /Q /R /S /X Delete Registry Key: 1 2 Remove-Item -Path \u0026#34;HKLM:\\Path\\To\\Registry\\Key\u0026#34; -Recurse Read Registry Key: 1 2 Get-ChildItem -Path \u0026#39;HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\\u0026#39; Retrieve Auto-Start Locations (Startup Programs) 1 Get-WmiObject -Query \u0026#34;SELECT * FROM Win32_StartupCommand\u0026#34; | Select-Object Name, Command, User List Installed Programs 1 Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, InstallDate Event Logs Search Sysmon Logs: 1 2 Get-WinEvent -FilterHashtable @{logname=\u0026#34;Microsoft-Windows-Sysmon/Operational\u0026#34;; id=1} | Where-Object {$_.Properties[20].Value -like \u0026#34;*rdpclip*\u0026#34;} | fl Login History: 1 2 Get-WinEvent -FilterHashtable @{LogName=\u0026#39;Security\u0026#39;;ID=4624,4625} | Select-Object TimeCreated, Id, Message Search Event Logs by Keyword: 1 2 Get-WinEvent -FilterHashtable @{ LogName=\u0026#39;Security\u0026#39;;} | Select Timecreated,LogName,Message | Where {$_.Message -like \u0026#34;*test*\u0026#34;} | FL Convert EVTX to CSV: 1 2 Get-WinEvent -Path .\\Microsoft-Windows-Sysmon%4Operational.evtx | Export-CSV foo.csv User and Account Information Local Users Information: 1 2 Get-LocalUser | Select * Get the SID from a Given Username: 1 2 3 4 5 6 7 8 $username = \u0026#34;Domain\\Username\u0026#34; $account = New-Object System.Security.Principal.NTAccount($username) $sid = $account.Translate([System.Security.Principal.SecurityIdentifier]).Value Write-Output $sid Translate SIDs: 1 2 3 4 5 6 7 8 $SID = \u0026#34;S-1-5-21-329068152-1454471165-1417001333-12984448\u0026#34; $account = New-Object System.Security.Principal.SecurityIdentifier($SID) $username = $account.Translate([System.Security.Principal.NTAccount]).Value Write-Output $username Job and Task Management Scheduled Tasks: 1 2 Get-ScheduledTask | Where-Object { $_.State -eq \u0026#39;Ready\u0026#39; } 1 2 Get-ScheduledJob File Operations Copy File: 1 2 Copy-Item -Source \\\\server\\share\\test -Destination C:\\path\\ Download File from Internet: 1 2 Invoke-WebRequest -Uri \u0026#34;https://download.sysinternals.com/files/Sysmon.zip\u0026#34; -OutFile $env:TEMP\\sysmon.zip Unzip File: 1 2 Expand-Archive -Path \u0026lt;SourcePathofZipFile\u0026gt; -DestinationPath \u0026lt;DestinationPath\u0026gt; Encrypt File: 1 2 Read-Host -Prompt \u0026#34;Enter the encryption passphrase\u0026#34; -AsSecureString | ConvertFrom-SecureString | Set-Content -Path \u0026#34;C:\\Path\\EncryptedFile.txt\u0026#34; Web Operations Upload File to Web: 1 2 3 4 5 6 $filePath = \u0026#34;C:\\Path\\To\\File.txt\u0026#34; $uploadUrl = \u0026#34;http://example.com/upload\u0026#34; Invoke-RestMethod -Uri $uploadUrl -Method POST -InFile $filePath Miscellaneous Generate Random Data (10MB): 1 2 $fileSizeInMB = 10; $filePath = \u0026#34;$PWD\\file.txt\u0026#34;; $data = [byte[]]::new($fileSizeInMB * 1MB); $random = New-Object -TypeName System.Random; $random.NextBytes($data); [System.IO.File]::WriteAllBytes($filePath, $data) Regex Matching for Specific String (\u0026ldquo;feras\u0026rdquo;): 1 2 Select-String -Path C:\\path\\strings.txt -Pattern \u0026#39;\\bferas\\b\u0026#39; -AllMatches | % { $_.Matches } | % { $_.Value } Linux cut command\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Cut function powershell function cut { param( [Parameter(ValueFromPipeline=$True)] [string]$inputobject, [string]$delimiter=\u0026#39;\\s+\u0026#39;, [string[]]$field ) process { if ($field -eq $null) { $inputobject -split $delimiter } else { ($inputobject -split $delimiter)[$field] } } } PowerShell with Security Utilities PowerShell enhances security utilities like Sysinternals for effective IR:\nSysinternals: Start utilities like Process Explorer:\n1 Start-Process \u0026#34;C:\\Path\\To\\ProcessExplorer.exe\u0026#34; Remote Commands: Use PsExec to run commands on target machines:\n1 .\\PsExec.exe \\\\TargetMachine cmd Data Collection: Retrieve logs from Sysmon:\n1 Get-WinEvent -LogName \u0026#39;Microsoft-Windows-Sysmon/Operational\u0026#39; ","date":"2024-07-07T00:00:00Z","image":"https://feras454.github.io/p/useful-powershell-commands-for-incident-response-ir-triage/powershell_hu4238673040972007764.webp","permalink":"https://feras454.github.io/p/useful-powershell-commands-for-incident-response-ir-triage/","title":"Useful PowerShell Commands for Incident Response (IR) triage"},{"content":"Hi ðŸ‘‹, in this post, weâ€™ll explore common Docker misconfigurations attackers exploit to compromise systems, such as exposed APIs and privileged containers, with detection strategies for threat hunters.\nExposed Docker APIs Exposing Docker\u0026rsquo;s API to the internet without authentication allows attackers full control over containers.\nExploitation Attackers use tools like Shodan to find exposed APIs on ports 2375 or 2376 and create containers remotely:\n1 curl -X POST http://\u0026lt;docker_host_ip\u0026gt;:2375/containers/create -d \u0026#39;{\u0026#34;Image\u0026#34;:\u0026#34;alpine\u0026#34;}\u0026#39; Detection Use Nmap to scan for open Docker API ports: 1 nmap -p 2375 --open \u0026lt;target_subnet\u0026gt; Monitor API logs for requests from external IPs. Privileged Containers Running containers in privileged mode gives attackers root-level access to the host.\nExploitation An attacker inside a privileged container can mount the host\u0026rsquo;s root directory:\n1 docker run --privileged -v /:/host --rm -it alpine chroot /host Detection Identify privileged containers:\n1 docker inspect --format \u0026#39;{{ .HostConfig.Privileged }}\u0026#39; $(docker ps -q) Insecure Volume Mounts Improper mounts of sensitive directories (like /etc or /root) give attackers access to critical host data.\nExploitation Attackers can mount the host file system:\n1 2 docker run -v /:/host --rm -it alpine /bin/sh cat /host/etc/shadow Detection Check for dangerous mounts:\n1 docker inspect --format \u0026#39;{{ .Mounts }}\u0026#39; $(docker ps -q) Cgroups and Namespace Escapes Excessive privileges, like SYS_ADMIN, can break Docker\u0026rsquo;s isolation.\nExploitation Run a container with the SYS_ADMIN capability to escape to the host:\n1 docker run --cap-add=SYS_ADMIN -it alpine /bin/sh Detection Inspect running containers for dangerous capabilities:\n1 docker inspect --format \u0026#39;{{ .HostConfig.CapAdd }}\u0026#39; $(docker ps -q) Resource Exhaustion: Denial of Service Containers without resource limits can overwhelm system resources, leading to Denial of Service (DoS) attacks.\nExploitation Run a container to consume excessive CPU:\n1 docker run --rm -it --cpu-shares=1024 --memory=1g stress --cpu 8 --timeout 60 Detection Monitor resource usage with docker stats:\n1 docker stats References:\nDocker Security Best Practices Docker Security Cheat Sheet ","date":"2023-11-27T00:00:00Z","image":"https://feras454.github.io/p/threat-hunting-in-docker-uncovering-weaknesses/dockerr_hu11573327607075044336.webp","permalink":"https://feras454.github.io/p/threat-hunting-in-docker-uncovering-weaknesses/","title":"Threat Hunting in Docker Uncovering Weaknesses"},{"content":"Introduction This project is part of the Machine Learning for Cybersecurity course I am taking as a cybersecurity student at the university. While I am not an ML engineer, this blog outlines how to implement a deep learning model to detect malicious URLs. I will demonstrate how a neural network can classify URLs as benign or malicious using specific features. Basic ML knowledge is required, but deep expertise is not necessary.\nDataset The dataset used is the Malicious URLs Phishing Dataset, which contains benign and malicious URLs. The dataset and full project code are available on GitHub.\nStep-by-Step Code Breakdown Step 1: Importing Necessary Libraries 1 2 3 4 5 6 7 8 9 10 11 import pandas as pd import numpy as np import tensorflow as tf from matplotlib import pyplot as plt import re from urllib.parse import urlparse from keras.models import Sequential from keras.layers import Dense from sklearn.model_selection import train_test_split from sklearn.preprocessing import LabelEncoder from sklearn.metrics import accuracy_score, classification_report, confusion_matrix Step 2: Loading the Dataset 1 2 3 # You can find the dataset on my github repo data = pd.read_csv(\u0026#39;malicious_phish.csv\u0026#39;) print(data.type.value_counts()) Step 3: Feature Engineering Custom functions extract features like the presence of an IP address, URL length, and count of sensitive words. The features and their descriptions are listed below:\nFeature Description use_of_ip Whether the URL contains an IP address. url_length The total length of the URL. numOf-https Count of \u0026lsquo;https\u0026rsquo; occurrences in the URL. numOf-http Count of \u0026lsquo;http\u0026rsquo; occurrences in the URL. hostname_length Length of the hostname part of the URL. count-digits Number of digits in the URL. count-letters Number of alphabetic characters in the URL. NumSensitiveWords Whether the URL contains sensitive words like \u0026lsquo;PayPal,\u0026rsquo; \u0026rsquo;login,\u0026rsquo; or \u0026lsquo;bank.\u0026rsquo; numOf. Count of periods (\u0026rsquo;.\u0026rsquo;) in the URL. numOf% Count of \u0026lsquo;%\u0026rsquo; in the URL. numOf? Count of \u0026lsquo;?\u0026rsquo; in the URL. numOf- Count of dashes (\u0026rsquo;-\u0026rsquo;) in the URL. numOf= Count of equal signs (\u0026rsquo;=\u0026rsquo;) in the URL. abnormal_url Whether the URL contains abnormal structures. binary Binary representation of the URL\u0026rsquo;s classification (0 for benign, 1 for malicious). Each of these features was chosen because they are commonly found in malicious URLs, such as the presence of IP addresses, which are often used to evade detection, and sensitive keywords like \u0026rsquo;login\u0026rsquo; or \u0026lsquo;bank,\u0026rsquo; which are frequently used in phishing URLs.\n1 2 3 4 5 6 7 8 def having_ip_address(url): match = re.search(\u0026#39;...\u0026#39;, url) return 1 if match else 0 data[\u0026#39;use_of_ip\u0026#39;] = data[\u0026#39;url\u0026#39;].apply(having_ip_address) data[\u0026#39;url_length\u0026#39;] = data[\u0026#39;url\u0026#39;].apply(lambda i: len(i)) data[\u0026#39;numOf-https\u0026#39;] = data[\u0026#39;url\u0026#39;].apply(lambda i: i.count(\u0026#39;https\u0026#39;)) # Additional features are also extracted... Step 4: Label Encoding 1 2 3 lb_make = LabelEncoder() data[\u0026#39;class\u0026#39;] = lb_make.fit_transform(data[\u0026#39;type\u0026#39;]) print(data[\u0026#39;class\u0026#39;].head()) In this project, label encoding is applied to the type column, which contains the categorical URL types (e.g., \u0026ldquo;benign\u0026rdquo;, \u0026ldquo;phishing\u0026rdquo;, \u0026ldquo;malware\u0026rdquo;), to convert them into numerical values that the model can process. The LabelEncoder from sklearn.preprocessing is used to transform the text labels into integers.\nStep 5: Data Splitting 1 2 3 X = data[[\u0026#39;use_of_ip\u0026#39;, \u0026#39;url_length\u0026#39;, \u0026#39;NumSensitiveWords\u0026#39;, \u0026#39;numOf-https\u0026#39;]] y = data[\u0026#39;class\u0026#39;] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=5) Step 6: Neural Network Model 1 2 3 4 model = Sequential() model.add(Dense(128, input_shape=(X_train.shape[1],), activation=\u0026#39;relu\u0026#39;)) model.add(Dense(64, activation=\u0026#39;relu\u0026#39;)) model.add(Dense(4, activation=\u0026#39;softmax\u0026#39;)) The model uses two dense layers with ReLU activation to capture non-linear patterns, and the final layer uses softmax for multi-class classification\n![[Head.png]]\nStep 7: Compiling and Training the Model 1 2 model.compile(optimizer=\u0026#39;adam\u0026#39;, loss=\u0026#39;categorical_crossentropy\u0026#39;, metrics=[\u0026#39;categorical_accuracy\u0026#39;]) history = model.fit(X_train, y_train, epochs=20, validation_data=(X_test, y_test)) Step 8: Model Evaluation 1 2 loss, accuracy = model.evaluate(X_test, y_test, verbose=False) print(f\u0026#39;Test accuracy: {accuracy:.3}\u0026#39;) The accuracy curve shows steady learning over the epochs, and the low loss indicates that the model is fitting the data well without overfitting\n![[Pasted image 20241026151743.png]]\nStep 9: Visualizing Accuracy and Loss 1 2 3 4 5 plt.plot(history.history[\u0026#39;categorical_accuracy\u0026#39;], label=\u0026#39;Training Accuracy\u0026#39;) plt.plot(history.history[\u0026#39;val_categorical_accuracy\u0026#39;], label=\u0026#39;Validation Accuracy\u0026#39;) plt.title(\u0026#39;Model Accuracy\u0026#39;) plt.legend() plt.show() Conclusion This project demonstrates the application of machine learning in detecting malicious URLs. The full code and dataset can be accessed on GitHub.\nReferences Ma, J., Saul, L. K., Savage, S., and Voelker, G. M. (2009). Beyond Blacklists: Learning to Detect Malicious Web Sites from Suspicious URLs. Proceedings of the 15th ACM SIGKDD Conference on Knowledge Discovery and Data Mining. Verma, R. and Hossain, N. (2017). Phish-Zoo: Detecting Phishing Websites By Looking At Them. IEEE Transactions on Dependable and Secure Computing. Basnet, R., Mukkamala, S., and Sung, A. H. (2008). Detection of Phishing Attacks: A Machine Learning Approach. Studies in Fuzziness and Soft Computing. Buczak, A. L., and Guven, E. (2016). A Survey of Data Mining and Machine Learning Methods for Cybersecurity Intrusion Detection. IEEE Communications Surveys \u0026amp; Tutorials. ","date":"2022-11-07T00:00:00Z","image":"https://feras454.github.io/p/machine-learning-detection-of-malicious-urls-with-implementation-using-keras/banner_hu15347318682138986697.png","permalink":"https://feras454.github.io/p/machine-learning-detection-of-malicious-urls-with-implementation-using-keras/","title":"Machine Learning Detection of Malicious URLs with Implementation Using Keras"}]